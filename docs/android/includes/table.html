<table width="100%" border="1px">
<tr>
    <td><b>屬性</b></td>
    <td><b>描述</b></td>
    <td><b>選項</b></td>
</tr>
<tr>
    <td><code> abi.type </code></td>
    <td><strong>ABI 類型</strong> – 指定模擬裝置的 ABI (應用程式二進位介面) 類型。<code>x86</code> 選項是用於指令集，通常稱為 "x86" 或 "IA-32"。 <code>x86_64</code> 選項是用於 64 位元 x86 指令集。<code>armeabi-v7a</code> 選項是用於具有 v7-a ARM 擴充功能的 ARM 指令集。<code>arm64-v8a</code> 選項是用於支援 AArch64 的 ARM 指令集。 </td>
    <td> x86、x86_64、armeabi-v7a、arm64-v8a </td>
</tr>
<tr>
    <td><code> disk.cachePartition </code></td>
    <td><strong>快取磁碟分割</strong> – 決定模擬裝置是否將使用裝置上的 <strong>/cache</strong> 磁碟分割。<strong>/cache</strong> 磁碟分割 (一開始是空的) 是 Android 儲存經常存取之資料和應用程式元件的位置。如果設定為 <code>no</code>，模擬器將不會使用 <strong>/cache</strong> 磁碟分割，並且會忽略其他 <code>disk.cache</code> 設定。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> disk.cachePartition.path </code></td>
    <td><strong>快取磁碟分割路徑</strong> – 指定您開發電腦上的快取磁碟分割映像檔。模擬器將會使用此檔案作為 <strong>/cache</strong> 磁碟分割。請輸入絕對路徑或模擬器 [data]<strong></strong> 目錄的相對路徑。如果未設定，模擬器會在您的開發電腦上建立一個名為 <strong>cache.img</strong> 的暫存檔。如果該檔案不存在，就會建立成空檔案。如果將 <code>disk.cachePartition</code> 設定為 <code>no</code>，則會忽略此選項。</td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.cachePartition.size </code></td>
    <td><strong>快取磁碟分割大小</strong> – 快取磁碟分割檔案的大小 (單位為 MB)。通常您不需要設定此選項，除非應用程式將下載大於 66 MB 預設快取大小的非常大型檔案，。如果將 <code>disk.cachePartition</code> 設定為 <code>no</code>，則會忽略此選項。</td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.dataPartition.initPath </code></td>
    <td><strong>資料磁碟分割的初始路徑</strong> – 指定資料磁碟分割的初始內容。抹除使用者資料之後，模擬器會將所指定檔案的內容複製到使用者資料 (預設為 <strong>userdata-qemu.img</strong>) 中，而不會使用 <strong>userdata.img</strong> 作為初始版本。</td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.dataPartition.path </code></td>
    <td><strong>資料磁碟分割的路徑</strong> – 指定使用者資料磁碟分割檔案。若要設定持續性使用者資料檔案，請輸入檔案名稱和您開發電腦上的路徑。如果該檔案不存在，模擬器就會從預設檔案 <strong>userdata.img</strong> 建立映像、將它儲存在 <code>disk.dataPartition.path</code> 所指定的檔案名稱中，然後在模擬器關閉時，將使用者資料保存至該檔案。如果您未指定路徑，預設檔案會命名為 <strong>userdata-qemu.img</strong>。特殊值 <code>&lt;temp></code> 會導致模擬器建立和使用暫存檔。如果已設定 <code>disk.dataPartition.initPath</code>，開機時，就會將其內容複製到 <code>disk.dataPartition.path</code> 檔案。請注意，這個選項不能留白。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.dataPartition.size </code></td>
    <td><strong>資料磁碟分割大小</strong> – 指定使用者資料磁碟分割的大小 (單位為 MB)。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.ramdisk.path </code></td>
    <td><strong>Ramdisk 路徑</strong> – 開機磁碟分割 (Ramdisk) 映像的路徑。Ramdisk 映像是在掛接系統映像之前，核心會先載入的系統映像子集。Ramdisk 映像通常包含開機時間二進位檔和初始化指令碼。如果未指定此選項，則預設會是模擬器系統目錄中的 <strong>ramdisk.img</strong>。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.snapStorage.path </code></td>
    <td><strong>快照儲存體路徑</strong> – 儲存所有快照的「快照儲存體檔案」<i></i>路徑。在執行期間建立的所有快照都會儲存至這個檔案。只有儲存至這個檔案的快照，才能在模擬器執行期間被還原。如果未指定此選項，則預設會是模擬器資料目錄中的 <strong>snapshots.img</strong>。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.systemPartition.initPath </code></td>
    <td><strong>系統磁碟分割初始路徑</strong> – 系統映像檔唯讀複本的路徑；具體而言，就是包含系統程式庫及與 API 層級和任何變體對應之資料的磁碟分割。如果未指定此路徑，則預設會是模擬器系統目錄中的 <strong>system.img</strong>。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.systemPartition.path </code></td>
    <td><strong>系統磁碟分割路徑</strong>– 讀取/寫入系統磁碟分割映像的路徑。如果未設定此路徑，就會從 <code>disk.systemPartition.initPath</code> 所指定檔案的內容建立暫存檔並初始化。</td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.systemPartition.size </code></td>
    <td><strong>系統磁碟分割大小</strong> – 系統磁碟分割的理想大小 (單位為 MB)。如果實際系統磁碟分割映像大於此設定，便會忽略此大小；否則，這會指定系統磁碟分割檔案可成長的大小上限。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.accelerometer </code></td>
    <td><strong>加速計</strong> – 決定模擬裝置是否包含加速計感應器。加速計可協助裝置判斷方向 (用於自動旋轉)。加速計會回報裝置加速情況及三個感應器軸。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.audioInput </code></td>
    <td><strong>音訊錄製支援</strong> – 決定模擬裝置是否可以錄製音訊。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.audioOutput </code></td>
    <td><strong>音訊播放支援</strong> – 決定模擬裝置是否可以播放音訊。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.battery </code></td>
    <td><strong>電池支援</strong> – 決定模擬裝置是否可以靠電池電力運行。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.camera </code></td>
    <td><strong>相機支援</strong> – 決定模擬裝置是否具有相機。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.camera.back </code></td>
    <td><strong>後置相機</strong> – 設定後置相機 (鏡頭朝使用者的反方向)。如果您使用開發電腦上的網路攝影機來模擬模擬裝置上的後置相機，就必須將此值設定為 <code>webcam<i>n</i></code>，其中 <i>n</i> 會選取網路攝影機 (如果您只有一個網路攝影機，請選擇 <code>webcam0</code>)。如果設定為 <code>emulated</code>，模擬器就會以軟體模擬相機。若要停用後置相機，請將此值設定為 <code>none</code>。如果您啟用後置相機，請務必一併啟用 <code>hw.camera</code>。 </td>
    <td> emulated、none、webcam0 </td>
</tr>
<tr>
    <td><code> hw.camera.front </code></td>
    <td><strong>前置相機</strong> – 設定前置相機 (鏡頭朝向使用者的方向)。如果您使用開發電腦上的網路攝影機來模擬模擬裝置上的前置相機，就必須將此值設定為 <code>webcam<i>n</i></code>，其中 <i>n</i> 會選取網路攝影機 (如果您只有一個網路攝影機，請選擇 <code>webcam0</code>)。如果設定為 <code>emulated</code>，模擬器就會以軟體模擬相機。若要停用前置相機，請將此值設定為 <code>none</code>。如果您啟用前置相機，請務必一併啟用 <code>hw.camera</code>。 </td>
    <td> emulated、none、webcam0 </td>
</tr>
<tr>
    <td><code> hw.camera.maxHorizontalPixels </code></td>
    <td><strong>最大水平相機像素</strong> – 設定模擬裝置的相機最大水平解析度 (單位為像素)。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.camera.maxVerticalPixels </code></td>
    <td><strong>最大垂直相機像素</strong> – 設定模擬裝置的相機最大垂直解析度 (單位為像素)。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.cpu.arch </code></td>
    <td><strong>CPU 架構</strong> – 虛擬裝置所要模擬的 CPU 架構。如果您使用 Intel HAXM 來進行硬體加速，請針對 32 位元 CPU 選取 <code>x86</code>。針對 64 位元 HAXM 加速裝置，則選取 <code>x86_64</code>。(請務必在 SDK Manager 中安裝對應的 Intel x86 系統映像：例如 <strong>Intel x86 Atom</strong> 或 <strong>Intel x86 Atom_64</strong>)。 若要模擬 ARM CPU，請針對 32 位元選取 <code>arm</code>，或針對 64 位元 ARM CPU 選取 <code>arm64</code>。請記住，ARM 型虛擬裝置的執行速度比 x86 型慢很多，因為 ARM 無法使用硬體加速。 </td>
    <td> x86、x86_64、arm、arm64 </td>
</tr>
<tr>
    <td><code> hw.cpu.model </code></td>
    <td><strong>CPU 型號</strong> – 此值通常保留不設定 (在未明確設定的情況下，它會設定為衍生自 <code>hw.cpu.arch</code> 的值)。不過，可以將它設定為模擬器特定字串以供實驗使用。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.dPad </code></td>
    <td><strong>DPad 按鍵</strong> – 決定模擬裝置是否支援方向鍵 (DPad) 按鍵。DPad 通常有四個按鍵來指示方向控制。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.gps </code></td>
    <td><strong>GPS 支援</strong> – 決定模擬裝置是否具有 GPS (全球定位系統) 接收器。 </td>
    <td> yes、no </td>
<tr>
</tr>
<tr>
    <td><code> hw.gpu.enabled </code></td>
    <td><strong>GPU 模擬</strong> – 決定模擬裝置是否支援 GPU 模擬。啟用時，GPU 模擬會使用 Open GL for Embedded Systems (OpenGL ES) 來轉譯畫面上的 2D 和 3D 圖形，而關聯的「GPU 模擬模式」設定則會決定 GPU 模擬的實作方式。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.gpu.mode </code></td>
    <td><strong>GPU 模擬模式</strong> – 決定模擬器實作 GPU 模擬的方式。如果您選取 <code>auto</code>，模擬器將會根據您的開發電腦設定來選擇硬體和軟體加速。如果您選取 <code>host</code>，模擬器將會使用您開發電腦的圖形處理器來執行 GPU 模擬以加快轉譯速度。如果您的 GPU 與模擬器不相容且您使用 Windows，則您可以嘗試使用 <code>angle</code>，而不使用 <code>host</code>。<code>angle</code> 模式會使用 DirectX 來提供與 <code>host</code> 類似的效能。如果您選取 <code>mesa</code>，模擬器將會使用 Mesa 3D 軟體程式庫來轉譯圖形。當您無法透過開發電腦的圖形處理器進行轉譯時，請選取 <code>mesa</code>。在效能比使用電腦 GPU 稍差的軟體中，可以使用 <code>swiftshader</code> 模式來轉譯圖形。<code>off</code> 選項 (停用圖形硬體模擬) 是已被取代的選項，此選項可能導致某些項目轉譯不正確，因此不建議使用。</td>
    <td> auto、host、mesa、angle、swiftshader、off </td>
</tr>
<tr>
    <td><code> hw.gsmModem </code></td>
    <td><strong>GSM 數據機支援</strong> – 決定模擬裝置是否包含支援 GSM (全球行動通訊系統) 電話無線電系統的數據機。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.initialOrientation </code></td>
    <td><strong>初始螢幕方向</strong> – 設定模擬裝置上的初始螢幕方向 (直向或橫向模式)。在直向模式中，螢幕高度會大於寬度。在橫向模式中，螢幕寬度會大於高度。執行模擬裝置時，如果裝置設定檔中同時支援直向和橫向模式，您就可以變更方向。 </td>
    <td> portrait、landscape </td>
</tr>
<tr>
    <td><code> hw.keyboard </code></td>
    <td><strong>鍵盤支援</strong> – 決定模擬裝置是否支援 QWERTY 鍵盤。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.keyboard.charmap </code></td>
    <td><strong>鍵盤字元對應名稱</strong> – 此裝置的硬體字元對應名稱。注意：這應該一律是預設的 <code>qwerty2</code>，除非您已相應地修改系統映像。此名稱會在開機時傳送至核心。使用的名稱如果不正確，將會造成虛擬裝置無法使用。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.keyboard.lid </code></td>
    <td><strong>鍵盤蓋支援</strong> – 如果已啟用鍵盤支援，此設定可決定是否可以將 QWERTY 鍵盤關閉/隱藏或開啟/顯示。如果將 <code>hw.keyboard</code> 設定為 <code>false</code>，就會忽略此設定。注意：如果模擬裝置的目標是 API 層級 12 或更高層級，則預設值為 <code>false</code>。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.lcd.backlight </code></td>
    <td><strong>LCD 背光</strong> – 決定模擬裝置是否要模擬 LCD 背光。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.lcd.density </code></td>
    <td><strong>LCD 密度</strong> – 所模擬 LCD 顯示器的密度，測量單位為密度獨立像素 (或 <i>dp</i>，dp 是虛擬像素單位)。當此設定為 160 dp 時，每個 dp 會對應一個實體像素。在執行階段，Android 會使用此值來選取和調整適當的資源/資產，來進行正確的顯示器轉譯。 </td>
    <td> 120、160、240、213、320 </td>
</tr>
<tr>
    <td><code> hw.lcd.depth </code></td>
    <td><strong>LCD 色彩深度</strong> – 所模擬 framebuffer 的色彩位元深度，framebuffer 會保存用於驅動 LCD 顯示的點陣圖。此值可以是 16 位元 (65,536 個可能的色彩) 或 32 位元 (16,777,216 個色彩再加上透明度)。32 位元設定可能讓模擬器執行速度稍微慢一些，但可提供較精確的色彩。 </td>
    <td> 16, 32 </td>
</tr>
<tr>
    <td><code> hw.lcd.height </code></td>
    <td><strong>LCD 像素高度</strong> – 構成所模擬 LCD 顯示器之垂直維度的像素數目。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.lcd.width </code></td>
    <td><strong>LCD 像素寬度</strong> – 構成所模擬 LCD 顯示器之水平維度的像素數目。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.mainKeys </code></td>
    <td><strong>硬體上一頁/首頁按鍵</strong> – 決定模擬裝置是否支援硬體「上一頁」和「首頁」導覽按鈕。如果只在軟體中實作按鈕，您可以將此值設定為 <code>yes</code>。如果將 <code>hw.mainKeys</code> 設定為 <code>yes</code>，模擬器將不會在螢幕上顯示導覽按鈕，但您可以使用模擬器側邊面板來「按」這些按鈕。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.ramSize </code></td>
    <td><strong>裝置 RAM 大小</strong> – 模擬裝置上的實體 RAM 數量 (單位為 MB)。將會從螢幕大小或面板版本計算出預設值。將大小增大可以加快模擬器作業速度，但代價是會從您的開發電腦要求更多資源。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.screen </code></td>
    <td><strong>觸控式螢幕類型</strong> – 定義模擬裝置上螢幕的類型。<code>multi-touch</code> 螢幕可追蹤觸控式介面上兩根以上的手指。<code>touch</code> 螢幕只能偵測單一手指觸控事件。<code>no-touch</code> 螢幕不會偵測觸控事件。 </td>
    <td> touch、multi-touch、no-touch </td>
</tr>
<tr>
    <td><code> hw.sdCard </code></td>
    <td><strong>SDCard 支援</strong> – 決定模擬裝置是否支援插入和移除虛擬 SD (Secure Digital) 記憶卡。模擬器會使用儲存在您開發電腦上的可掛接磁碟映像，來模擬實際 SD 記憶卡裝置的磁碟分割 (請參閱 <code>hw.sdCard.path</code>)。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> sdcard.size </code></td>
    <td><strong>SDCard 大小</strong> – 指定位於 <code>hw.sdCard.path</code> 所指定裝置上可用位置之虛擬 SD 記憶卡檔案的大小 (單位為位元組)。如果此大小為簡單整數，就會以位元組為單位來指定大小。您也可以使用 KB、MB 及 GB 為單位來指定此大小，方法是在大小附加 K、M 或 G。大小下限為 9M，大小上限為 1023G。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.sdCard.path </code></td>
    <td><strong>SDCard 映像路徑</strong> – 指定您開發電腦上 SD 記憶卡磁碟分割映像檔的檔案名稱和路徑。例如，可以將此路徑設定為 Windows 上的 <strong>C:\sd\sdcard.img</strong>。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.sensors.magnetic_field </code></td>
    <td><strong>磁場感應器</strong> – 決定模擬裝置是否支援磁場感應器。磁場感應器 (也稱為磁力計) 會回報沿著三個感應器軸測量到的周遭地球磁場。如果應用程式需要存取羅盤讀數，請啟用此設定。例如，導航應用程式可能會使用此感應器來偵測使用者所正對的方向。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.sensors.orientation </code></td>
    <td><strong>方向感應器</strong> – 決定模擬裝置是否提供方向感應器值。方向感應器會測量裝置圍繞三個實體軸 (x、y、z) 進行的旋轉角度。請注意，方向感應器自 Android 2.2 (API 層級 8) 起即以被取代。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.sensors.proximity </code></td>
    <td><strong>近接感應器</strong> – 決定模擬裝置是否支援近接感應器。此感應器會測量物件相對於裝置檢視螢幕的鄰近程度。此感應器通常用來判斷話筒是否正舉到使用者的耳邊。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.sensors.temperature </code></td>
    <td><strong>溫度感應器</strong> – 決定模擬裝置是否支援溫度感應器。此感應器會測量裝置的攝氏溫度 (°C)。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.touchScreen </code></td>
    <td><strong>觸控式螢幕支援</strong> – 決定模擬裝置是否支援觸控式螢幕。觸控式螢幕是用來在螢幕上直接操控物件。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.trackBall </code></td>
    <td><strong>軌跡球支援</strong> – 決定模擬裝置是否支援軌跡球。 </td>
    <td> yes、no </td>
</tr>
<tr>
    <td><code> hw.useext4 </code></td>
    <td><strong>EXT4 檔案系統支援</strong> – 決定模擬裝置是否使用 Linux EXT4 檔案系統作為磁碟分割。由於檔案系統類型現在採用自動偵測，因此這個選項已被取代並忽略。 </td>
    <td> 否 </td>
</tr>
<tr>
    <td><code> kernel.newDeviceNaming </code></td>
    <td><strong>核心新裝置命名</strong> – 用來指定核心是否需要新的裝置命名配置。這通常與 Linux 3.10 核心或更新版本搭配使用。如果設定為 <code>autodetect</code>，模擬器將會自動偵測核心是否需要新的命名配置。 </td>
    <td> autodetect、yes、no </td>
</tr>
<tr>
    <td><code> kernel.parameters </code></td>
    <td><strong>核心參數</strong> – 指定 Linux 核心開機參數的字串。此設定預設會留白。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> kernel.path </code></td>
    <td><strong>核心路徑</strong> – 指定 Linux 核心的路徑。如果未指定此路徑，模擬器就會查看模擬器系統目錄中是否有 <code>kernel-ranchu</code>。 </td>
    <td>  </td>
</tr>
<tr>
    <td><code> kernel.supportsYaffs2 </code></td>
    <td><strong>YAFFS2 磁碟分割支援</strong> – 決定核心是否支援 YAFFS2 (Yet Another Flash File System 2) 磁碟分割。一般而言，這僅適用於 Linux 3.10 之前的核心。如果設定為 <code>autodetect</code>，模擬器將會自動偵測核心是否可以掛接 YAFFS2 檔案系統。 </td>
    <td> autodetect、yes、no </td>
</tr>
<tr>
    <td><code> skin.name </code></td>
    <td><strong>面板名稱</strong> – Android 模擬器面板的名稱。面板是一個檔案集合，定義了模擬器顯示畫面的視覺和控制元素；它會描述 AVD 視窗在您開發電腦上看起來的樣子。面板會描述螢幕大小、按鈕及整體設計，但不會影響您應用程式的操作。</td>
    <td> </td>
</tr>
<tr>
    <td><code> skin.path </code></td>
    <td><strong>面板路徑</strong> – 包含 <code>skin.name</code> 中所指定模擬器面板檔案的目錄路徑。此目錄包含 <code>hardware.ini</code> 版面配置檔案，以及面板顯示元素的影像檔。</td>
    <td> </td>
</tr>
<tr>
    <td><code> skin.dynamic </code></td>
    <td><strong>面板動態</strong> – 面板是否為動態面板。如果模擬器要根據指定的寬度和高度來建構指定大小的面板，則模擬器面板為動態面板。</td>
    <td> 否 </td>
</tr>
</table>
